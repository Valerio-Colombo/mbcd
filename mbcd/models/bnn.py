from __future__ import division
from __future__ import print_function
from __future__ import absolute_import

import os
import time
import pdb
import itertools
from collections import OrderedDict

import tensorflow as tf
import numpy as np
from tqdm import trange
from scipy.io import savemat, loadmat

from mbcd.models.utils import get_required_argument, TensorStandardScaler
from mbcd.models.fc import FC
from mbcd.utils.logger import Progress, Silent
from sklearn.preprocessing import PolynomialFeatures

np.set_printoptions(precision=4)


class BNN:
    """Neural network models which model aleatoric uncertainty (and possibly epistemic uncertainty
    with ensembling).
    Code adapted from https://github.com/JannerM/mbpo/blob/master/mbpo/models/bnn.py
    """

    def __init__(self, params):
        """Initializes a class instance.

        Arguments:
            params (DotMap): A dotmap of model parameters.
                .name (str): Model name, used for logging/use in variable scopes.
                    Warning: Models with the same name will overwrite each other.
                .num_networks (int): (optional) The number of networks in the ensemble. Defaults to 1.
                    Ignored if model is being loaded.
                .model_dir (str/None): (optional) Path to directory from which model will be loaded, and
                    saved by default. Defaults to None.
                .load_model (bool): (optional) If True, model will be loaded from the model directory,
                    assuming that the files are generated by a model of the same name. Defaults to False.
                .sess (tf.Session/None): The session that this model will use.
                    If None, creates a session with its own associated graph. Defaults to None.
        """
        self.name = get_required_argument(params, 'name', 'Must provide name.')
        self.model_dir = params.get('model_dir', None)

        print('[ BNN ] Initializing model: {} | {} networks | {} elites'.format(params['name'], params['num_networks'],
                                                                                params['num_elites']))
        if params.get('sess', None) is None:
            # config = tf.ConfigProto(device_count = {'GPU': 0})
            config = tf.ConfigProto()
            config.gpu_options.allow_growth = True
            self._sess = tf.Session(config=config)
        else:
            self._sess = params.get('sess')

        # Instance variables
        self.finalized = False
        self.layers, self.max_logvar, self.min_logvar = [], None, None
        self.decays, self.optvars, self.nonoptvars = [], [], []
        self.end_act, self.end_act_name = None, None
        self.scaler = None

        # Training objects
        self.train_loss = None
        self.accum_grads = None
        self.zero_ops = None
        self.accum_ops = None
        self.scale_coeff = None
        self.learning_rate = None
        self.optimizer = None
        self.sy_train_in, self.sy_train_targ = None, None
        self.grads, self.graph_vars = None, None
        self.train_op, self.train_op_rescaled, self.mse_loss = None, None, None
        self.val_mask = np.zeros([4096], dtype=bool)
        self.val_mask_a = False

        # Prediction objects
        self.sy_pred_in2d, self.sy_pred_mean2d_fac, self.sy_pred_var2d_fac = None, None, None
        self.sy_pred_mean2d, self.sy_pred_var2d = None, None
        self.sy_pred_in3d, self.sy_pred_mean3d_fac, self.sy_pred_var3d_fac = None, None, None

        if params.get('load_model', False):
            if self.model_dir is None:
                raise ValueError("Cannot load model without providing model directory.")
            self._load_structure()
            self.num_nets, self.model_loaded = self.layers[0].get_ensemble_size(), True
            print("Model loaded from %s." % self.model_dir)
            self.num_elites = params['num_elites']
        else:
            self.num_nets = params.get('num_networks', 1)
            self.num_elites = params['num_elites']  # params.get('num_elites', 1)
            self.model_loaded = False

        if self.num_nets == 1:
            print("Created a neural network with variance predictions.")
        else:
            print(
                "Created an ensemble of {} neural networks with variance predictions | Elites: {}".format(self.num_nets,
                                                                                                          self.num_elites))

        self._model_inds = [i for i in range(self.num_nets)]

    @property
    def is_probabilistic(self):
        return True

    @property
    def is_tf_model(self):
        return True

    @property
    def sess(self):
        return self._sess

    ###################################
    # Network Structure Setup Methods #
    ###################################

    def add(self, layer):
        """Adds a new layer to the network.

        Arguments:
            layer: (layer) The new layer to be added to the network.
                   If this is the first layer, the input dimension of the layer must be set.

        Returns: None.
        """
        if self.finalized:
            raise RuntimeError("Cannot modify network structure after finalizing.")
        if len(self.layers) == 0 and layer.get_input_dim() is None:
            raise ValueError("Must set input dimension for the first layer.")
        if self.model_loaded:
            raise RuntimeError("Cannot add layers to a loaded model.")

        layer.set_ensemble_size(self.num_nets)
        if len(self.layers) > 0:
            layer.set_input_dim(self.layers[-1].get_output_dim())
        self.layers.append(layer.copy())

    def pop(self):
        """Removes and returns the most recently added layer to the network.

        Returns: (layer) The removed layer.
        """
        if len(self.layers) == 0:
            raise RuntimeError("Network is empty.")
        if self.finalized:
            raise RuntimeError("Cannot modify network structure after finalizing.")
        if self.model_loaded:
            raise RuntimeError("Cannot remove layers from a loaded model.")

        return self.layers.pop()

    def finalize(self, optimizer, optimizer_args=None, *args, **kwargs):
        """Finalizes the network.

        Arguments:
            optimizer: (tf.train.Optimizer) An optimizer class from those available at tf.train.Optimizer.
            optimizer_args: (dict) A dictionary of arguments for the __init__ method of the chosen optimizer.

        Returns: None
        """
        if len(self.layers) == 0:
            raise RuntimeError("Cannot finalize an empty network.")
        if self.finalized:
            raise RuntimeError("Can only finalize a network once.")

        optimizer_args = {} if optimizer_args is None else optimizer_args

        self.learning_rate = optimizer_args.get("learning_rate")
        self.optimizer = optimizer(**optimizer_args)

        # Add variance output.
        self.layers[-1].set_output_dim(2 * self.layers[-1].get_output_dim())

        # Remove last activation to isolate variance from activation function.
        self.end_act = self.layers[-1].get_activation()
        self.end_act_name = self.layers[-1].get_activation(as_func=False)
        self.layers[-1].unset_activation()

        # Construct all variables.
        with self.sess.as_default():
            with tf.variable_scope(self.name):
                self.scaler = TensorStandardScaler(self.name, self.layers[0].get_input_dim())
                self.max_logvar = tf.Variable(np.ones([1, self.layers[-1].get_output_dim() // 2]) / 2.,
                                              dtype=tf.float32,
                                              name="max_log_var")
                self.min_logvar = tf.Variable(-np.ones([1, self.layers[-1].get_output_dim() // 2]) * 10.,
                                              dtype=tf.float32,
                                              name="min_log_var")
                for i, layer in enumerate(self.layers):
                    with tf.variable_scope(self.name + "Layer%i" % i):
                        layer.construct_vars()
                        self.decays.extend(layer.get_decays())
                        self.optvars.extend(layer.get_vars())
        self.optvars.extend([self.max_logvar, self.min_logvar])
        self.nonoptvars.extend(self.scaler.get_vars())

        # Set up training
        with tf.variable_scope(self.name):
            self.optimizer = optimizer(**optimizer_args)
            self.sy_train_in = tf.placeholder(dtype=tf.float32,
                                              shape=[self.num_nets, None, self.layers[0].get_input_dim()],
                                              name="training_inputs")
            self.sy_train_targ = tf.placeholder(dtype=tf.float32,
                                                shape=[self.num_nets, None, self.layers[-1].get_output_dim() // 2],
                                                name="training_targets")
            self.train_loss = tf.reduce_sum(
                self._compile_losses(self.sy_train_in, self.sy_train_targ, inc_var_loss=True))
            self.train_loss += tf.add_n(self.decays)
            self.train_loss += 0.01 * tf.reduce_sum(self.max_logvar) - 0.01 * tf.reduce_sum(self.min_logvar)
            self.mse_loss = self._compile_losses(self.sy_train_in, self.sy_train_targ, inc_var_loss=False)

            self.train_op = self.optimizer.minimize(self.train_loss, var_list=self.optvars)
            self.grads, self.graph_vars = zip(*self.optimizer.compute_gradients(self.train_loss, var_list=self.optvars))

        self.scale_coeff = tf.placeholder(tf.float32)

        # Accumulation ops and variables
        # create a copy of all trainable variables with `0` as initial values
        self.accum_grads = [tf.Variable(tf.zeros_like(t_var.initialized_value()), trainable=False) for t_var in
                            self.optvars]
        print("OPTVARS: {}".format(self.optvars))
        print("TRAINABLEVARS: {}".format(tf.trainable_variables()))

        # create an op to zero all accumulated vars
        self.zero_ops = [tv.assign(tf.zeros_like(tv)) for tv in self.accum_grads]

        # Create ops for accumulating the gradient
        self.accum_ops = [accum_grad.assign_add(grad * self.scale_coeff) for (accum_grad, grad) in
                          zip(self.accum_grads, self.grads)]

        self.train_op_rescaled = self.optimizer.apply_gradients(zip(self.accum_grads, self.graph_vars))

        # Initialize all variables
        self.sess.run(tf.global_variables_initializer())
        # self.sess.run(tf.variables_initializer(self.optvars + self.nonoptvars + self.optimizer.variables()))

        # Set up prediction
        with tf.variable_scope(self.name):
            self.sy_pred_in2d = tf.placeholder(dtype=tf.float32,
                                               shape=[None, self.layers[0].get_input_dim()],
                                               name="2D_training_inputs")
            self.sy_pred_mean2d_fac, self.sy_pred_var2d_fac = self.create_prediction_tensors(self.sy_pred_in2d,
                                                                                             factored=True)
            self.sy_pred_mean2d = tf.reduce_mean(self.sy_pred_mean2d_fac, axis=0)
            self.sy_pred_var2d = tf.reduce_mean(self.sy_pred_var2d_fac, axis=0) + tf.reduce_mean(
                tf.square(self.sy_pred_mean2d_fac - self.sy_pred_mean2d), axis=0)

            self.sy_pred_in3d = tf.placeholder(dtype=tf.float32,
                                               shape=[self.num_nets, None, self.layers[0].get_input_dim()],
                                               name="3D_training_inputs")
            self.sy_pred_mean3d_fac, self.sy_pred_var3d_fac = self.create_prediction_tensors(self.sy_pred_in3d,
                                                                                             factored=True)

        # Load model if needed
        if self.model_loaded:
            with self.sess.as_default():
                params_dict = loadmat(os.path.join(self.model_dir, "%s.mat" % self.name))
                all_vars = self.nonoptvars + self.optvars
                for i, var in enumerate(all_vars):
                    var.load(params_dict[str(i)])
        self.finalized = True

    ##################
    # Custom Methods #
    ##################

    def get_weights(self):
        return {idx: [layer.get_model_vars(idx, self.sess) for layer in self.layers] for idx in range(self.num_nets)}

    def set_weights(self, weights):
        keys = ['weights', 'biases']
        ops = []
        num_layers = len(self.layers)
        for layer in range(num_layers):
            # net_state = self._state[i]
            params = {key: np.stack([weights[net][layer][key] for net in range(self.num_nets)]) for key in keys}
            ops.extend(self.layers[layer].set_model_vars(params))
        self.sess.run(ops)

    def _save_state(self, idx):
        self._state[idx] = [layer.get_model_vars(idx, self.sess) for layer in self.layers]

    def _set_state(self):
        keys = ['weights', 'biases']
        # ops = []
        num_layers = len(self.layers)
        for layer in range(num_layers):
            # net_state = self._state[i]
            params = {key: np.stack([self._state[net][layer][key] for net in range(self.num_nets)]) for key in keys}
            self.layers[layer].set_model_vars(params, self.sess)
            # ops.extend()
        # self.sess.run(ops)

    def _save_best(self, epoch, holdout_losses):
        updated = False
        for i in range(len(holdout_losses)):
            current = holdout_losses[i]
            _, best = self._snapshots[i]
            improvement = (best - current) / best
            if improvement > 0.01:
                self._snapshots[i] = (epoch, current)
                self._save_state(i)
                updated = True
                improvement = (best - current) / best
                # print('epoch {} | updated {} | improvement: {:.4f} | best: {:.4f} | current: {:.4f}'.format(epoch, i, improvement, best, current))

        if updated:
            self._epochs_since_update = 0
        else:
            self._epochs_since_update += 1

        if self._epochs_since_update > self._max_epochs_since_update:
            # print('[ BNN ] Breaking at epoch {}: {} epochs since update ({} max)'.format(epoch, self._epochs_since_update, self._max_epochs_since_update))
            return True
        else:
            return False

    def _start_train(self):
        self._state = {}
        self._snapshots = {i: (None, 1e10) for i in range(self.num_nets)}
        self._epochs_since_update = 0

    def _end_train(self, holdout_losses):
        sorted_inds = np.argsort(holdout_losses)
        self._model_inds = sorted_inds[:self.num_elites].tolist()
        print('Using {} / {} models: {}'.format(self.num_elites, self.num_nets, self._model_inds))

    def random_inds(self, batch_size):
        inds = np.random.choice(self._model_inds, size=batch_size)
        return inds

    def reset(self):
        print('[ BNN ] Resetting model')
        [layer.reset(self.sess) for layer in self.layers]

    def validate(self, inputs, targets):
        inputs = np.tile(inputs[None], [self.num_nets, 1, 1])
        targets = np.tile(targets[None], [self.num_nets, 1, 1])
        losses = self.sess.run(
            self.mse_loss,
            feed_dict={
                self.sy_train_in: inputs,
                self.sy_train_targ: targets
            }
        )
        mean_elite_loss = np.sort(losses)[:self.num_elites].mean()
        return mean_elite_loss

    #################
    # Model Methods #
    #################

    # @profile
    def train(self, inputs, targets, window_size,
              batch_size=32, max_epochs=None, max_epochs_since_update=5,
              hide_progress=False, holdout_ratio=0.0, max_logging=5000, max_grad_updates=None, timer=None,
              max_t=None):
        """Trains/Continues network training
        Arguments:
            inputs (np.ndarray): Network inputs in the training dataset in rows.
            targets (np.ndarray): Network target outputs in the training dataset in rows corresponding
                to the rows in inputs.
            batch_size (int): The minibatch size to be used for training.
            epochs (int): Number of epochs (full network passes that will be done.
            hide_progress (bool): If True, hides the progress bar shown at the beginning of training.
        Returns: None
        """
        self._max_epochs_since_update = max_epochs_since_update
        self._start_train()
        break_train = False

        def shuffle_rows(arr):
            idxs = np.argsort(np.random.uniform(size=arr.shape), axis=-1)
            return arr[np.arange(arr.shape[0])[:, None], idxs]

        with self.sess.as_default():
            self.scaler.fit(inputs)

        # Split into training and holdout sets
        def shift_l(arr, num, fill_value, val_perc):
            num = -num
            result = np.empty_like(arr)
            if num > 0:
                result[:num] = fill_value
                result[num:] = arr[:-num]
            elif num < 0:
                result[num:] = fill_value
                result[:num] = arr[-num:]
            else:
                result[:] = arr
            n_val_r = np.sum(result)
            n_val = int(arr.shape[0] * val_perc)
            val_to_add = n_val - n_val_r

            i = np.random.choice(-num, val_to_add, replace=False) + arr.shape[0] + num
            result[i] = 1
            return result

        N = inputs.shape[0]
        if N == 4096:
            print("A")
            if self.val_mask_a:
                self.val_mask = shift_l(self.val_mask, window_size, 0, holdout_ratio)
                inputs, holdout_inputs = inputs[np.invert(self.val_mask)], inputs[self.val_mask]
                targets, holdout_targets = targets[np.invert(self.val_mask)], targets[self.val_mask]
                holdout_inputs = np.tile(holdout_inputs[None], [self.num_nets, 1, 1])
                holdout_targets = np.tile(holdout_targets[None], [self.num_nets, 1, 1])
            else:
                self.val_mask_a = True

                num_holdout = min(int(inputs.shape[0] * holdout_ratio), max_logging)
                permutation = np.random.permutation(inputs.shape[0])
                inputs, holdout_inputs = inputs[permutation[num_holdout:]], inputs[permutation[:num_holdout]]
                targets, holdout_targets = targets[permutation[num_holdout:]], targets[permutation[:num_holdout]]
                holdout_inputs = np.tile(holdout_inputs[None], [self.num_nets, 1, 1])
                holdout_targets = np.tile(holdout_targets[None], [self.num_nets, 1, 1])

                self.val_mask[permutation[:num_holdout]] = 1
        else:
            num_holdout = min(int(inputs.shape[0] * holdout_ratio), max_logging)
            permutation = np.random.permutation(inputs.shape[0])
            inputs, holdout_inputs = inputs[permutation[num_holdout:]], inputs[permutation[:num_holdout]]
            targets, holdout_targets = targets[permutation[num_holdout:]], targets[permutation[:num_holdout]]
            holdout_inputs = np.tile(holdout_inputs[None], [self.num_nets, 1, 1])
            holdout_targets = np.tile(holdout_targets[None], [self.num_nets, 1, 1])

        print('\n[ BNN ] Training {} | Holdout: {}'.format(inputs.shape, holdout_inputs.shape))

        idxs = np.random.randint(inputs.shape[0], size=[self.num_nets, inputs.shape[0]])
        if hide_progress:
            progress = Silent()
        else:
            progress = Progress(max_epochs)

        if max_epochs:
            epoch_iter = range(max_epochs)
        else:
            epoch_iter = itertools.count()

        # else:
        #     epoch_range = trange(epochs, unit="epoch(s)", desc="Network training")

        t0 = time.time()
        grad_updates = 0
        for epoch in epoch_iter:
            # print("Normal - Epoch: {}".format(epoch))
            for batch_num in range(int(np.ceil(idxs.shape[-1] / batch_size))):
                batch_idxs = idxs[:, batch_num * batch_size:(batch_num + 1) * batch_size]
                self.sess.run(
                    self.train_op,
                    feed_dict={self.sy_train_in: inputs[batch_idxs],
                               self.sy_train_targ: targets[batch_idxs],
                               self.learning_rate: 0.001}
                )
                # print("Classic loss: {}".format(loss))
                grad_updates += 1

            idxs = shuffle_rows(idxs)
            if not hide_progress:
                if holdout_ratio < 1e-12:
                    losses = self.sess.run(
                        self.mse_loss,
                        feed_dict={
                            self.sy_train_in: inputs[idxs[:, :max_logging]],
                            self.sy_train_targ: targets[idxs[:, :max_logging]]
                        }
                    )
                    named_losses = [['M{}'.format(i), losses[i]] for i in range(len(losses))]
                    progress.set_description(named_losses)
                else:
                    losses = self.sess.run(
                        self.mse_loss,
                        feed_dict={
                            self.sy_train_in: inputs[idxs[:, :max_logging]],
                            self.sy_train_targ: targets[idxs[:, :max_logging]]
                        }
                    )
                    holdout_losses = self.sess.run(
                        self.mse_loss,
                        feed_dict={
                            self.sy_train_in: holdout_inputs,
                            self.sy_train_targ: holdout_targets
                        }
                    )
                    named_losses = [['M{}'.format(i), losses[i]] for i in range(len(losses))]
                    named_holdout_losses = [['V{}'.format(i), holdout_losses[i]] for i in
                                            range(len(holdout_losses))]
                    named_losses = named_losses + named_holdout_losses + [['T', time.time() - t0]]
                    progress.set_description(named_losses)

                    break_train = self._save_best(epoch, holdout_losses)

            progress.update()
            t = time.time() - t0
            if break_train or (max_grad_updates and grad_updates > max_grad_updates):
                break
            if max_t and t > max_t:
                descr = 'Breaking because of timeout: {}! (max: {})'.format(t, max_t)
                progress.append_description(descr)
                # print('Breaking because of timeout: {}! | (max: {})\n'.format(t, max_t))
                # time.sleep(5)
                break
        print("Trained with normal for {} epochs".format(epoch + 1))

        if holdout_ratio > 0:
            progress.stamp()
            if timer: timer.stamp('bnn_train')

            self._set_state()
            if timer: timer.stamp('bnn_set_state')

            holdout_losses = self.sess.run(
                self.mse_loss,
                feed_dict={
                    self.sy_train_in: holdout_inputs,
                    self.sy_train_targ: holdout_targets
                }
            )

            if timer: timer.stamp('bnn_holdout')

            self._end_train(holdout_losses)
            if timer: timer.stamp('bnn_end')

            val_loss = (np.sort(holdout_losses)[:self.num_elites]).mean()
            model_metrics = {'val_loss': val_loss}
            print('[ BNN ] Holdout', np.sort(holdout_losses), model_metrics, '\n')
            return OrderedDict(model_metrics)
            # return np.sort(holdout_losses)[]

            # pdb.set_trace()
        else:
            self._model_inds = [0, 1, 2, 3, 4]

    def generate_grad_coeff_poly(self, num_batch=40, poly_grade=4):
        poly = PolynomialFeatures(poly_grade)

        scale = 1
        x = np.linspace(0, num_batch * scale, num=num_batch)
        phi = poly.fit_transform(x[:, np.newaxis])
        proto_H = np.matmul(np.linalg.inv(np.matmul(phi.transpose(), phi)), phi.transpose())
        fut_step = np.array([num_batch])[None]
        grad = np.matmul(poly.fit_transform(fut_step), proto_H)
        # grad = np.flip(grad)

        return grad

    def exp_basis(self, x):
        return np.array([1, np.power(1.1, x)])

    def generate_grad_coeff_exp(self, num_batch=40):  # low->high
        x = np.linspace(0, num_batch * 1.15, num=num_batch)
        basis_dim = self.exp_basis(1).shape[0]

        phi = np.ones([num_batch, basis_dim])
        for idx in range(num_batch):
            phi[idx] = self.exp_basis(x[idx])
        proto_H = np.matmul(np.linalg.inv(np.matmul(phi.transpose(), phi)), phi.transpose())
        fut_step_t = self.exp_basis(num_batch)
        grad = np.matmul(fut_step_t, proto_H)
        # grad = np.flip(grad)

        return grad

    # @profile
    def train_modified_holdout(self, inputs, targets,
                               batch_size=32, max_epochs=None, max_epochs_since_update=5,
                               hide_progress=False, holdout_ratio=0.0, max_logging=5000,
                               max_grad_updates=None, timer=None, max_t=None, lr=0.001):
        """Trains/Continues network training

        Arguments:
            inputs (np.ndarray): Network inputs in the training dataset in rows.
            targets (np.ndarray): Network target outputs in the training dataset in rows corresponding
                to the rows in inputs.
            batch_size (int): The minibatch size to be used for training.
            epochs (int): Number of epochs (full network passes that will be done.
            hide_progress (bool): If True, hides the progress bar shown at the beginning of training.

        Returns: None
        """
        self._max_epochs_since_update = max_epochs_since_update
        self._start_train()
        break_train = False

        def shuffle_rows(arr):
            idxs = np.argsort(np.random.uniform(size=arr.shape), axis=-1)
            return arr[np.arange(arr.shape[0])[:, None], idxs]

        with self.sess.as_default():
            self.scaler.fit(inputs)

        num_holdout = min(int(inputs.shape[0] * holdout_ratio), max_logging)

        ############
        # 1) Calculate gradient and sampling coefficients
        total_num_batch = int(np.floor(inputs.shape[0] / batch_size))
        scale_coeff = self.generate_grad_coeff_exp(num_batch=total_num_batch)
        # scale_coeff = np.full((total_num_batch), 1/total_num_batch)
        # scale_coeff = self.generate_grad_coeff_poly(num_batch=total_num_batch, poly_grade=4)
        sampling_coeff = np.repeat(scale_coeff, batch_size)
        for i in range(sampling_coeff.shape[0]):
            if sampling_coeff[i] < 0:
                sampling_coeff[i] = 0
        sampling_coeff = sampling_coeff / np.sum(sampling_coeff)  # normalize
        print("Sampling coeff sum: {}".format(np.sum(sampling_coeff)))

        # 2) Sample holdout set
        idx_holdout = np.empty([num_holdout], dtype=int)
        idxs_i = np.arange(inputs.shape[0], dtype=int)[-total_num_batch * batch_size:]

        for s in range(num_holdout):
            idx_holdout[s] = np.random.choice(a=idxs_i, p=sampling_coeff)

        holdout_inputs = inputs[idx_holdout]
        holdout_inputs = np.tile(holdout_inputs[None], [self.num_nets, 1, 1])
        holdout_targets = targets[idx_holdout]
        holdout_targets = np.tile(holdout_targets[None], [self.num_nets, 1, 1])

        # 3) Delete holdout data from inputs
        train_inputs = np.delete(inputs, idx_holdout, axis=0)
        train_targets = np.delete(targets, idx_holdout, axis=0)

        train_num_batch = int(np.floor(train_inputs.shape[0] / batch_size))
        train_inputs = train_inputs[-train_num_batch * batch_size:]
        train_targets = train_targets[-train_num_batch * batch_size:]

        # 4) Divide in batches

        train_inputs_b = np.array(np.split(train_inputs, train_num_batch))
        train_targets_b = np.array(np.split(train_targets, train_num_batch))

        ############

        # permutation = np.random.permutation(inputs.shape[0])
        # inputs, holdout_inputs = inputs[num_holdout:], inputs[:num_holdout]
        # targets, holdout_targets = targets[num_holdout:], targets[:num_holdout]
        # holdout_inputs = np.tile(holdout_inputs[None], [self.num_nets, 1, 1])
        # holdout_targets = np.tile(holdout_targets[None], [self.num_nets, 1, 1])

        print('[ BNN ] Training {} | Holdout: {}'.format(inputs.shape, holdout_inputs.shape))

        # idxs = np.random.randint(inputs.shape[0], size=[self.num_nets, inputs.shape[0]])
        if hide_progress:
            progress = Silent()
        else:
            progress = Progress(max_epochs)

        if max_epochs:
            epoch_iter = range(max_epochs)
        else:
            epoch_iter = itertools.count()

        # else:
        #     epoch_range = trange(epochs, unit="epoch(s)", desc="Network training")

        # total_num_batch = int(np.ceil(idxs.shape[-1] / batch_size))
        #
        # # scale_coeff = self.generate_grad_coeff_poly(num_batch=total_num_batch, poly_grade=2)
        # scale_coeff = self.generate_grad_coeff_exp(num_batch=total_num_batch)

        t0 = time.time()
        grad_updates = 0
        for epoch in epoch_iter:
            print("Modified - Epoch: {}".format(epoch))
            for batch_num in range(train_num_batch):
                # batch_idxs = np.arange(inputs.shape[0] - batch_size * (batch_num + 1),
                #                        inputs.shape[0] - batch_size * batch_num)
                # batch_idxs_arr = [batch_idxs for _ in range(self.num_nets)]
                # arrays_stack = np.stack(batch_idxs_arr, axis=0)
                curr_train_inputs = train_inputs_b[train_num_batch - batch_num - 1]
                curr_train_targets = train_targets_b[train_num_batch - batch_num - 1]

                curr_idxs = np.arange(batch_size)
                np.random.shuffle(curr_idxs)
                curr_train_inputs = curr_train_inputs[curr_idxs]
                curr_train_targets = curr_train_targets[curr_idxs]

                curr_train_inputs = [curr_train_inputs for _ in range(self.num_nets)]
                curr_train_targets = [curr_train_targets for _ in range(self.num_nets)]

                _, _loss = self.sess.run(
                    (self.accum_ops, self.train_loss),
                    feed_dict={self.sy_train_in: curr_train_inputs,
                               self.sy_train_targ: curr_train_targets,
                               self.scale_coeff: scale_coeff.item(total_num_batch - batch_num - 1)}
                    # TODO invert. No more flip!!!! - ?
                )
                losses = self.sess.run(
                    self.mse_loss,
                    feed_dict={
                        self.sy_train_in: curr_train_inputs,
                        self.sy_train_targ: curr_train_targets
                    }
                )
                # print("Epoch: {} - Batch: {} - Train Loss: {} - MSE loss: {} - Coeff: {}".format(epoch, batch_num,
                #                                                                                  _loss, losses,
                #                                                                                  scale_coeff.item(
                #                                                                                  total_num_batch - batch_num - 1)))

                grad_updates += 1

            self.sess.run(self.train_op_rescaled, feed_dict={self.learning_rate: lr})  # apply gradient
            self.sess.run(self.zero_ops)  # reset for next epoch

            # idxs = shuffle_rows(idxs)
            if not hide_progress:
                if holdout_ratio < 1e-12:
                    if train_inputs.shape[0] > max_logging:
                        train_inputs_loss = train_inputs[-max_logging:]
                        train_targets_loss = train_targets[-max_logging:]
                    else:
                        train_inputs_loss = train_inputs
                        train_targets_loss = train_targets

                    train_inputs_loss = [train_inputs_loss for _ in range(self.num_nets)]
                    train_targets_loss = [train_targets_loss for _ in range(self.num_nets)]

                    losses = self.sess.run(
                        self.mse_loss,
                        feed_dict={
                            self.sy_train_in: train_inputs_loss,
                            self.sy_train_targ: train_targets_loss
                        }
                    )
                    named_losses = [['M{}'.format(i), losses[i]] for i in range(len(losses))]
                    progress.set_description(named_losses)
                else:
                    if train_inputs.shape[0] > max_logging:
                        train_inputs_loss = train_inputs[-max_logging:]
                        train_targets_loss = train_targets[-max_logging:]
                    else:
                        train_inputs_loss = train_inputs
                        train_targets_loss = train_targets

                    train_inputs_loss = [train_inputs_loss for _ in range(self.num_nets)]
                    train_targets_loss = [train_targets_loss for _ in range(self.num_nets)]

                    losses = self.sess.run(
                        self.mse_loss,
                        feed_dict={
                            self.sy_train_in: train_inputs_loss,
                            self.sy_train_targ: train_targets_loss
                        }
                    )
                    holdout_losses = self.sess.run(
                        self.mse_loss,
                        feed_dict={
                            self.sy_train_in: holdout_inputs,
                            self.sy_train_targ: holdout_targets
                        }
                    )
                    named_losses = [['M{}'.format(i), losses[i]] for i in range(len(losses))]
                    named_holdout_losses = [['V{}'.format(i), holdout_losses[i]] for i in
                                            range(len(holdout_losses))]
                    named_losses = named_losses + named_holdout_losses + [['T', time.time() - t0]]
                    progress.set_description(named_losses)

                    break_train = self._save_best(epoch, holdout_losses)

            progress.update()
            t = time.time() - t0
            if break_train or (max_grad_updates and grad_updates > max_grad_updates):
                break
            if max_t and t > max_t:
                descr = 'Breaking because of timeout: {}! (max: {})'.format(t, max_t)
                progress.append_description(descr)
                # print('Breaking because of timeout: {}! | (max: {})\n'.format(t, max_t))
                # time.sleep(5)
                break
        print("Trained with modified for {} epochs".format(epoch+1))

        if holdout_ratio > 0:
            progress.stamp()
            if timer: timer.stamp('bnn_train')

            self._set_state()
            if timer: timer.stamp('bnn_set_state')

            holdout_losses = self.sess.run(
                self.mse_loss,
                feed_dict={
                    self.sy_train_in: holdout_inputs,
                    self.sy_train_targ: holdout_targets
                }
            )

            if timer: timer.stamp('bnn_holdout')

            self._end_train(holdout_losses)
            if timer: timer.stamp('bnn_end')

            val_loss = (np.sort(holdout_losses)[:self.num_elites]).mean()
            model_metrics = {'val_loss': val_loss}
            print('[ BNN ] Holdout', np.sort(holdout_losses), model_metrics)
            return OrderedDict(model_metrics)
            # return np.sort(holdout_losses)[]

            # pdb.set_trace()
        else:
            self._model_inds = [0, 1, 2, 3, 4]

    def predict(self, inputs, factored=False, *args, **kwargs):
        """Returns the distribution predicted by the model for each input vector in inputs.
        Behavior is affected by the dimensionality of inputs and factored as follows:

        inputs is 2D, factored=True: Each row is treated as an input vector.
            Returns a mean of shape [ensemble_size, batch_size, output_dim] and variance of shape
            [ensemble_size, batch_size, output_dim], where N(mean[i, j, :], diag([i, j, :])) is the
            predicted output distribution by the ith model in the ensemble on input vector j.

        inputs is 2D, factored=False: Each row is treated as an input vector.
            Returns a mean of shape [batch_size, output_dim] and variance of shape
            [batch_size, output_dim], where aggregation is performed as described in the paper.

        inputs is 3D, factored=True/False: Each row in the last dimension is treated as an input vector.
            Returns a mean of shape [ensemble_size, batch_size, output_dim] and variance of sha
            [ensemble_size, batch_size, output_dim], where N(mean[i, j, :], diag([i, j, :])) is the
            predicted output distribution by the ith model in the ensemble on input vector [i, j].

        Arguments:
            inputs (np.ndarray): An array of input vectors in rows. See above for behavior.
            factored (bool): See above for behavior.
        """
        if len(inputs.shape) == 2:
            if factored:
                return self.sess.run(
                    [self.sy_pred_mean2d_fac, self.sy_pred_var2d_fac],
                    feed_dict={self.sy_pred_in2d: inputs}
                )
            else:
                return self.sess.run(
                    [self.sy_pred_mean2d, self.sy_pred_var2d],
                    feed_dict={self.sy_pred_in2d: inputs}
                )
        else:
            return self.sess.run(
                [self.sy_pred_mean3d_fac, self.sy_pred_var3d_fac],
                feed_dict={self.sy_pred_in3d: inputs}
            )

    def create_prediction_tensors(self, inputs, factored=False, *args, **kwargs):
        """See predict() above for documentation.
        """
        factored_mean, factored_variance = self._compile_outputs(inputs)
        if inputs.shape.ndims == 2 and not factored:
            mean = tf.reduce_mean(factored_mean, axis=0)
            variance = tf.reduce_mean(tf.square(factored_mean - mean), axis=0) + \
                       tf.reduce_mean(factored_variance, axis=0)
            return mean, variance
        return factored_mean, factored_variance

    def save_weights(self):
        # Save network parameters (including scalers) in a .mat file
        var_vals = {}
        for i, var_val in enumerate(self.sess.run(self.nonoptvars + self.optvars)):
            var_vals[str(i)] = var_val
        savemat('weights/' + self.name + '.mat', var_vals)

    def load_weights(self):
        with self.sess.as_default():
            params_dict = loadmat('weights/' + self.name + '.mat')
            all_vars = self.nonoptvars + self.optvars
            for i, var in enumerate(all_vars):
                var.load(params_dict[str(i)])

    def load_weights_id(self, model_id):
        with self.sess.as_default():
            name_new = list(self.name)
            name_new[-1] = str(model_id)
            name_new = ''.join(name_new)

            params_dict = loadmat('weights/' + name_new + '.mat')
            all_vars = self.nonoptvars + self.optvars
            for i, var in enumerate(all_vars):
                var.load(params_dict[str(i)])

    def save(self, savedir, timestep):
        """Saves all information required to recreate this model in two files in savedir
        (or self.model_dir if savedir is None), one containing the model structuure and the other
        containing all variables in the network.

        savedir (str): (Optional) Path to which files will be saved. If not provided, self.model_dir
            (the directory provided at initialization) will be used.
        """
        if not self.finalized:
            raise RuntimeError()
        model_dir = self.model_dir if savedir is None else savedir

        # Write structure to file
        with open(os.path.join(model_dir, '{}_{}.nns'.format(self.name, timestep)), "w+") as f:
            for layer in self.layers[:-1]:
                f.write("%s\n" % repr(layer))
            last_layer_copy = self.layers[-1].copy()
            last_layer_copy.set_activation(self.end_act_name)
            last_layer_copy.set_output_dim(last_layer_copy.get_output_dim() // 2)
            f.write("%s\n" % repr(last_layer_copy))

        # Save network parameters (including scalers) in a .mat file
        var_vals = {}
        for i, var_val in enumerate(self.sess.run(self.nonoptvars + self.optvars)):
            var_vals[str(i)] = var_val
        savemat(os.path.join(model_dir, '{}_{}.mat'.format(self.name, timestep)), var_vals)

    def _load_structure(self):
        """Uses the saved structure in self.model_dir with the name of this network to initialize
        the structure of this network.
        """
        structure = []
        with open(os.path.join(self.model_dir, "%s.nns" % self.name), "r") as f:
            for line in f:
                kwargs = {
                    key: val for (key, val) in
                    [argval.split("=") for argval in line[3:-2].split(", ")]
                }
                kwargs["input_dim"] = int(kwargs["input_dim"])
                kwargs["output_dim"] = int(kwargs["output_dim"])
                kwargs["weight_decay"] = None if kwargs["weight_decay"] == "None" else float(kwargs["weight_decay"])
                kwargs["activation"] = None if kwargs["activation"] == "None" else kwargs["activation"][1:-1]
                kwargs["ensemble_size"] = int(kwargs["ensemble_size"])
                structure.append(FC(**kwargs))
        self.layers = structure

    #######################
    # Compilation methods #
    #######################

    def _compile_outputs(self, inputs, ret_log_var=False):
        """Compiles the output of the network at the given inputs.

        If inputs is 2D, returns a 3D tensor where output[i] is the output of the ith network in the ensemble.
        If inputs is 3D, returns a 3D tensor where output[i] is the output of the ith network on the ith input matrix.

        Arguments:
            inputs: (tf.Tensor) A tensor representing the inputs to the network
            ret_log_var: (bool) If True, returns the log variance instead of the variance.

        Returns: (tf.Tensors) The mean and variance/log variance predictions at inputs for each network
            in the ensemble.
        """
        dim_output = self.layers[-1].get_output_dim()
        cur_out = self.scaler.transform(inputs)
        for layer in self.layers:
            cur_out = layer.compute_output_tensor(cur_out)

        mean = cur_out[:, :, :dim_output // 2]
        if self.end_act is not None:
            mean = self.end_act(mean)

        logvar = self.max_logvar - tf.nn.softplus(self.max_logvar - cur_out[:, :, dim_output // 2:])
        logvar = self.min_logvar + tf.nn.softplus(logvar - self.min_logvar)

        if ret_log_var:
            return mean, logvar
        else:
            return mean, tf.exp(logvar)

    def _compile_losses(self, inputs, targets, inc_var_loss=True):
        """Helper method for compiling the loss function.

        The loss function is obtained from the log likelihood, assuming that the output
        distribution is Gaussian, with both mean and (diagonal) covariance matrix being determined
        by network outputs.

        Arguments:
            inputs: (tf.Tensor) A tensor representing the input batch
            targets: (tf.Tensor) The desired targets for each input vector in inputs.
            inc_var_loss: (bool) If True, includes log variance loss.

        Returns: (tf.Tensor) A tensor representing the loss on the input arguments.
        """
        mean, log_var = self._compile_outputs(inputs, ret_log_var=True)
        inv_var = tf.exp(-log_var)

        if inc_var_loss:
            mse_losses = tf.reduce_mean(tf.reduce_mean(tf.square(mean - targets) * inv_var, axis=-1), axis=-1)
            var_losses = tf.reduce_mean(tf.reduce_mean(log_var, axis=-1), axis=-1)
            total_losses = mse_losses + var_losses
        else:
            total_losses = tf.reduce_mean(tf.reduce_mean(tf.square(mean - targets), axis=-1), axis=-1)

        return total_losses